"""
From : https://projecteuler.net/problem=12
Context : The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would
be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

            1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:
         1: 1
         3: 1,3
         6: 1,2,3,6
        10: 1,2,5,10
        15: 1,3,5,15
        21: 1,3,7,21
        28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.

Goal : What is the value of the first triangle number to have over five hundred divisors?

Author : Alexandre Dorais
"""


# The problem, as it stands, seems like it requires us to find all the factors of every triangle number until we find
# one with more than 500 divisors. However, finding all the factors of one number is painstaking enough. It is actually
# much quicker to find the prime factors of a number. The question then becomes : is there a way to link the amount of
# prime factors and the total amount of factors for a given number. It turns out that there is. As an example, let's
# look at the number M = 60 (which is not a triangular number, but for the sake of example let's use it anyway). Its
# prime factors are obviously [2,2,3,5] and we can check that 2x2x3x5=60. Now, how can we use this information on prime
# factors to count how many factors 60 has? Obviously, all the factors of 60 need to be made from the product of numbers
# in the set of prime factors of 60. The trick is to ask : how many numbers can we create by multiplying the prime
# factors of 60. This is simply a combinatorial problem. With our set of [2,2,3,5], let's count how many numbers we can
# make using only multiplication. Let's start every multiplication with a 1. Then, we look at twos. We can choose to
# multiply our 1 by no 2, by one 2 or by two 2. This gives us 3 possibilities. From this new product, we look at threes,
# and realise that we can either multiply it by 3 or not, which gives us 2 branches. Same thing with fives, we can
# either multiply by 5 or not. This is another 2 branches. In the end, we find that there is 3 x 2 x 2 = 12 factors that
# can be made with the prime numbers from our set. We can list them out to make sure we have them all right. We have :
#       60: 1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30, 60
# If we count them, we find that 60 really does have 12 factors, as calculated.
# So, what does this mean for our algorithm? We will go through the triangle numbers in the sequence, and find their
# prime factors. Then, we will use our combinatorial trick to calculate how many factors the triangle number has, given
# its prime factorization, without actually finding all of its factors. The first number we find with over 500 divisors
# will be the answer. As an idea of how long we will need to look, we can spot that if a number has 9 distinct prime
# factors (no repeats), it will have 2^9 factors which evaluates to be 512. If there are repeats, this value changes a
# little, but it serves to give us an idea of how large a number we are looking for.

def main():
    # Initialization
    found = False
    current = 0
    n = 1
    answer = 0
    stop_criteria = 10000

    # List prime numbers under 1000
    prime_numbers = list_prime_numbers(stop_criteria)

    # Main loop
    while not found and current < stop_criteria ** 2:
        # Calculates a new triangular number every iteration
        current = n * (n + 1) // 2  # new triangle number with closed form formula
        n += 1

        print('current : ', current)

        # Find prime factors of current number
        prime_factorisation = find_prime_factors(current, prime_numbers)

        print('factored')

        # Count how many divisors the current triangle number has
        detailed_count = [[factor, prime_factorisation.count(factor)] for factor in set(prime_factorisation)]
        # detailed_count gives a nested list where every first element is a prime factor of the current number, and
        # every second element is the number of times that that factor appears in the prime factorisation of the current
        # number
        simple_count = 1
        for element in detailed_count:
            # if a prime factor appears k times in the list, it multiplies the possibilities of making divisors by (k+1)
            simple_count = simple_count * (element[1] + 1)

        print(detailed_count)
        print('# of factors : ', simple_count, '\n')

        if simple_count > 500:  # if there is more than 500 divisors
            found = True
            answer = current

    print(answer)


def list_prime_numbers(max_number):
    prime_numbers = list(range(max_number + 1))
    prime_numbers[1] = 0  # 1 is not prime

    for prime in prime_numbers:
        if prime:
            for multiplier in range(prime, max_number // prime + 1):
                prime_numbers[prime * multiplier] = 0  # replace non-primes with zeros

    prime_numbers = [i for i in prime_numbers if i != 0]  # clean up list to remove zeros

    return prime_numbers


def find_prime_factors(number, prime_numbers):
    flag = False
    prime_factorisation = []
    previous = number

    while not flag:
        for divisor in prime_numbers:
            if number % divisor == 0:
                prime_factorisation.append(divisor)
                number = number // divisor

        if number == 1:  # if the prime factorisation is complete
            flag = True  # let the program know
        elif previous == number:  # else if a whole loop through prime_numbers didn't give new divisors
            prime_numbers = list_prime_numbers(number)  # create a larger list of prime numbers
        previous = number

    print('prime factorisation : ', prime_factorisation)

    return prime_factorisation


main()
